# abstract

## purpose
the purpose of the project is to create a shared whiteboard web application for being hosted on some webserver. User shouldd have the possibility to share index cards on a shared whiteboard. The whiteboard itself should consist of four areas: Todo, In Progress, Done, Waste. Currently no rules or workflow is necessary - so cards, after creation can transition from any state to any other state without limitation.

## user flow
Users should be able to login via OIDC, against configurable OIDC environment. No guest of the system should be allowed at all, hence only authenticated users should be able to access the whiteboard and do meaningful things with the cards.

## card, whiteboard and integration with other users
Cards, placed on the whiteboard, transitions, any change basically, must be persisted and other currently connected users must be notified about the change immediately, Server Sent Events might be the weapon of choice for notifications.

## tooling
Basically from the perspective of tools and frameworks, a minimal set of tools should be used, preferrably just a git repository and it's rest api for persistance.

## language
A feasible language should be used, I was thinking of angular, but choose which seems the best choice for accomplishing the task.

## programming paradigm
The implementation should follow TDD style Acceptance test driven development (ATDD). So all production code should be created test driven, to ensure sustainable quality. The changes should be small and iteratively made. In case of success, good, in case of unsuccessful test result, the change should be reverted and a new, fresh, different attempt might be better. 100% of all tests need to pass on any change in production code, or the change is considered unsuccessful.

Never must production code and test be changed simultaniously.

Acceptance tests must describe upfront what the system should achieve. We use a 4 layer architecture.

Layer 1: The tests as executable specifiction of the system, written in the language of the project and formulated using a DSL - a domain specific language, that we define as Layer 2.

Layer 2: DSL - a domain specific language that defines common artifacts in the problem domain - Card, Whiteboard, User, Todo, In-Progress, Done, Waste, Create Card, Delete Card, etc.

Layer 3: Protocol-Driver: This is the only layer that has knowledge about the implementation detail. This layer connects the DSL to the system under test, which is Layer 4.

Layer 4: The system under test.

What benefit do we have by following that paradigm: Even if a test fails, the Test is valid as long as our assumptions about the problem we try to solve proof correct.

## first task
Please describe the overall goal we are trying to achieve here, define a programming language and tools we would need if we would follow your suggestion immediately and define an examaple set of ATDD tests based on the headings 'purpose', 'user flow' and 'card, whiteboard and integration with other users'.

### chats response
Overall goal: Build a shared whiteboard web app with four columns (Todo, In Progress, Done, Waste), OIDC-authenticated access only, realtime sync of card changes via SSE, and persistence through a minimal backend (ideally just a Git-backed REST API).

Suggested stack (minimal, fast to bootstrap):

Language: TypeScript end-to-end.
Frontend: Vite + Svelte (lightweight, easy state mgmt), talking to REST/SSE endpoints.
Backend: Node.js + Fastify (small footprint) or Express, with SSE endpoints; simple persistence layer using a Git-backed store (e.g., simple JSON files versioned via isomorphic-git) or lightweight SQLite if Git storage proves cumbersome.
Auth: oidc-client-ts on the frontend; openid-client on the backend for token validation.
Test tooling: Vitest for unit/DSL tests; Playwright for ATDD (Layer 1) to run executable specs against the running app; supertest for protocol-driver HTTP hooks if needed.
Example ATDD outline (Layer 1 executable specs using a tiny DSL). Pseudocode-ish to convey intent:

// Layer 2 DSL snippets
scenario("Authenticated user sees empty board", () => {
  given.userIsAuthenticated("alice");
  when.userVisitsBoard();
  then.boardShowsColumns(["Todo", "In Progress", "Done", "Waste"]);
  then.boardHasNoCards();
});

scenario("Create a card into Todo", () => {
  given.userIsAuthenticated("alice");
  when.userCreatesCard({ title: "Write tests", column: "Todo" });
  then.boardShowsCard("Write tests", "Todo");
  then.changeIsPersisted();
});

scenario("Move card between any states freely", () => {
  given.userIsAuthenticated("alice");
  given.cardExists({ title: "Draft spec", column: "Todo" });
  when.userMovesCard("Draft spec", "Waste");
  then.boardShowsCard("Draft spec", "Waste");
  then.changeIsPersisted();
});

scenario("Reject unauthenticated access", () => {
  given.userIsNotAuthenticated();
  when.userVisitsBoard();
  then.userIsRedirectedToOIDCLogin();
});

scenario("Realtime updates via SSE", () => {
  given.userIsAuthenticated("alice");
  given.userIsAuthenticated("bob");
  given.cardExists({ title: "Pair session", column: "In Progress" });
  when.userMovesCardAs("alice", "Pair session", "Done");
  then.otherUserSeesUpdateInUnder("bob", 2, "seconds");
  then.changeIsPersisted();
});
ATDD layering fit:

Layer 1: Above scenarios as executable tests (Playwright/Vitest runner).
Layer 2: given/when/then DSL abstractions (card, column, user).
Layer 3: Protocol driver bridges DSL to HTTP/SSE/UI actions.
Layer 4: App itself.
Benefits: Keeps specs stable even if implementation shifts; DSL reflects domain; protocol driver isolates app wiring; tests remain valid even on failure as long as assumptions hold. Natural next steps: pick the backend persistence (Git-backed vs SQLite), scaffold the DSL/test harness, and stand up minimal OIDC-configurable auth flow.