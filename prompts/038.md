# ATDD add priority to cards

The vertical position of a card in a swimlane should represent the priority. The higher the card, the higher the priority.
Swimlanes should hold references to cards and their respective order, meaning a card can be exclusively in a single swimlane at a point in time. The swimlane should keep order, the Cards are not aware of their order (= priority) on a swimlane.

```
scenario("Swimlanes order cards.", () => {
  given.cardExists({ title: "Draft spec 1", column: "Todo" });
  given.cardExists({ title: "Draft spec 2", column: "Todo" });
  then.swimlaneShowsCardInOrder({column: "Todo", ["Draft spec 1", "Draft spec 2"]);
});
```

```
scenario("Newly created Cards on always on top.", () => {
  given.userIsAuthenticated("alice");
  given.cardExists({ title: "Draft spec 1", column: "Todo"});
  when.userCreatesCard({ title: "Write tests", column: "Todo" });
  then.changeIsPersisted();
  then.swimlaneShowsCardInOrder({column: "Todo", ["Write tests", "Draft spec 1"]);
});
```

```
scenario("Move Card up on swimlane.", () => {
  given.userIsAuthenticated("alice");
  given.cardExists({ title: "Draft spec 1", column: "Todo"});
  given.cardExists({ title: "Draft spec 2", column: "Todo"});
  given.swimlaneShowsCardInOrder({column: "Todo", ["Draft spec 1", "Draft spec 2"]);
  when.userMovesCardUp({ title: "Draft spec 2", column: "Todo" });
  then.changeIsPersisted();
  given.swimlaneShowsCardInOrder({column: "Todo", ["Draft spec 2", "Draft spec 1"]);
});
```

```
scenario("Move Card down on swimlane.", () => {
  given.userIsAuthenticated("alice");
  given.cardExists({ title: "Draft spec 1", column: "Todo"});
  given.cardExists({ title: "Draft spec 2", column: "Todo"});
  given.swimlaneShowsCardInOrder({column: "Todo", ["Draft spec 1", "Draft spec 2"]);
  when.userMovesCardDown({ title: "Draft spec 1", column: "Todo" });
  then.changeIsPersisted();
  given.swimlaneShowsCardInOrder({column: "Todo", ["Draft spec 2", "Draft spec 1"]);
});
```

```
scenario("Move Card to another swimlane.", () => {
  given.userIsAuthenticated("alice");
  given.cardExists({ title: "Draft spec 1", column: "Todo"});
  given.cardExists({ title: "Draft spec 2", column: "Todo"});
  given.cardExists({ title: "Draft spec 3", column: "In Progress"});
  given.swimlaneShowsCardInOrder({column: "Todo", ["Draft spec 1", "Draft spec 2"]);
  given.swimlaneShowsCardInOrder({column: "In Progress", ["Draft spec 3"]);
  when.userMovesCardToSwimlane({ title: "Draft spec 1", column: "In Progress" });
  then.changeIsPersisted();
  given.swimlaneShowsCardInOrder({column: "Todo", ["Draft spec 2"]);
  given.swimlaneShowsCardInOrder({column: "In Progress", ["Draft spec 1", "Draft spec 3"]);
});
```

Options for resolving are
- Use a Separate "Ordering Metadata" Object With Sparse Values
- Create a Separate Ordering store

## chats response

Added explicit swimlane ordering metadata that persists with cards, normalizes old array-only data, orders listCards() by lane priority, and supports move up/down and cross-lane/top insertion while keeping cards oblivious to position (src/board.ts, src/server.ts uses ordered cards for SSE init).
Extended the ATDD DSL with swimlane order assertions and move helpers, and added scenarios covering creation priority, intra-lane reordering, and lane moves (tests/atdd/dsl.ts, tests/atdd/swimlanes.spec.ts).
Tests: npm test

Possible next steps: 1) Expose API endpoints/UI controls for move up/down and lane moves using the new service methods. 2) Review existing board.json consumers; saves now include swimlane ordering alongside cards.

4 files changed
+393
-39


board.ts
+242
-33

server.ts
+2
-5

dsl.ts
+71
-1

swimlanes.spec.ts
+78
-0

# proceed
1) expose API endpoints & UI controls for move up/down
and
2) Review existing board.json consumers; saves now include swimlane ordering alongside cards.

## chats response
Added move-priority plumbing end-to-end: server now exposes PATCH /api/cards/move-up and /api/cards/move-down using the swimlane ordering logic (src/server.ts). The UI renders up/down arrow buttons on each card and wires them to the new endpoints so users can reorder within a lane without switching columns (public/main.js).

Documented the updated persistence format so any board.json consumers know to expect { cards, swimlanes } with per-lane ordering preserved; legacy array files are still auto-normalized on load (README.md).

Tests: npm test

Natural next steps: 1) Consider disabling up/down buttons when already at top/bottom to reduce no-op calls. 2) If third-party readers write to board.json, update them to keep swimlanes consistent with cards.

3 files changed
+121
-0


README.md
+1
-0

main.js
+70
-0

server.ts
+50
-0